import { nanoid } from "nanoid";
import Color from "color";

export interface HasId {
  id: string;
}

export type CPoint = {
  x: number;
  y: number;
};

export const getRandomIntInclusive = (min: number, max: number) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive
};

export const loadImage = (
  setImageDimensions: React.Dispatch<
    React.SetStateAction<{
      width: number;
      height: number;
    }>
  >,
  imageUrl: string
) => {
  const img = new Image();
  img.src = imageUrl;

  img.onload = () => {
    setImageDimensions({
      width: img.width,
      height: img.height,
    });
  };
  img.onerror = (err) => {
    console.log("img error");
    console.error(err);
  };
};

export const clamp = (num: number, min: number, max: number) =>
  Math.max(min, Math.min(num, max));

export const prettyNumber = (num: number) =>
  num.toFixed(2).replace(/[.,]00$/, "");

export const isColorCloseMatch = (x: Color, y: Color, threshold = 50) => {
  const A = x.rgb();
  const B = y.rgb();

  const r = A.red() - B.red();
  const g = A.green() - B.green();
  const b = A.blue() - B.blue();

  return r * r + g * g + b * b <= threshold * threshold;
};

/**
 * openColor() normalizes alphas with the following priority:
 * 1. If the color = "transparent" then an alpha of 0 will be returned no matter what.
 * 2. If an alpha is passed as an argument, then it overrides the alpha generated by Color()
 *    For example, you might call openColor("rgba(20, 20, 20, 0.7)", 0.4),
 *    0.4 would be taken instead of 0.7 (0.7 would be generated by Color() inside the function).
 *    If you don't want the 0.7 to be taken then simply don't pass in alpha as the 2nd argument.
 * @param color any color space and the string "transparent"
 * @param alpha a number between 0 and 1 inclusive
 * @returns a color object, you can then call rgb(), hex(), hsl() etc to get the format you want
 * followed by a toString() depending on your use case.
 */
export const openColor = (color: string | number, alpha?: number) => {
  const c = Color(color);
  const a = color === "transparent" ? 0 : alpha ?? 1;
  return alpha ? c.alpha(a) : c;
};

export const colorToNumber = (color: string | number) =>
  new Color(color).rgbNumber();

export const getRandomColor = () => Color(getRandomIntInclusive(0, 0xffffff));

export function* generateColors(num_of_colors: number) {
  const step = num_of_colors < 360 ? 360 / num_of_colors : 1;

  const colors = [...Array(num_of_colors).keys()].map((i) =>
    new Color(`hsla(${(i * step) % 360}, 100%, 50%, 1)`).rgbNumber()
  );

  for (let color of colors) {
    yield color;
  }
}

/**
 * Turns an array of item objects with type T into
 * an object with key value (k, v) pairs of (id, T)
 * @param arr an array of objects with atleast an "id" key
 * @returns an object with id strings as its keys and the item object as the values
 */
export const arrayToObject = <T extends HasId>(arr: T[]) => {
  const objects: { [id: string]: T } = {};
  arr.forEach((item) => {
    objects[item.id] = item;
  });

  return objects;
};

export const mapToArray = <T>(map: { [id: string]: T }) =>
  Object.entries(map).map(([id, item]) => item);

export const roundIntToNearestMultiple = (num: number, multiple: number) =>
  Math.round(num / multiple) * multiple;

export const round10 = (num: number) => Math.round(num * 10) / 10;
export const round100 = (num: number) => Math.round(num * 100) / 100;

export const deepCopy = <T>(obj: T): T => JSON.parse(JSON.stringify(obj));

export const mergeProps = <T>(oldValue: T, newValue: Partial<T>): T => {
  const a = deepCopy(oldValue);
  const b = deepCopy(newValue);
  return { ...a, ...b };
};

export const zeroPad = (num: number, zeroes: number) =>
  String(num).padStart(zeroes, "0");
